<!DOCTYPE html>
<meta charset="utf-8">
<title>pathvisio.js renderer</title>

<!-- 
Style guides can be arbitrary, but for sake of consistency within this project, let's use these:
http://google-styleguide.googlecode.com/svn/trunk/htmlcssguide.xml
http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml
http://google-styleguide.googlecode.com/svn/trunk/jsoncstyleguide.xml#General_Guidelines
-->

<script src="../js/d3.v3/d3.v3.js" charset="utf-8"></script>
<script src="../js/gpml2json.js"></script>
<script src="../js/rgbcolor.js"></script>
<style>
text {
  font-size: 200px;
  font-family: "arial";
}
</style>

<object id="pathway-container" data="pathwaydefs.svg" type="image/svg+xml" width="100%" height="100%" onload="drawPathway()"></object>

<script>
function clone(selector) {
  var node = d3.select(selector).node();
  return d3.select(node.parentNode.insertBefore(node.cloneNode(true), node.nextSibling));
};

function splitTextByLines(text) {

  // PathVisio (Java) uses '&#xA;' for indicating newline, and browsers convert this into '\r\n' or '\n' in JavaScript.

  return text.split(/\r\n|\r|\n/g);
};

function getMarker(name, position, color) {
  var markerName = '';
  if (name === 'none') {
    markerName = name;
  }
  else {

    // if it's black, use the default

    if ( (color === '#000') || (color === '#000000') || (!(color)) ) {
      markerName = name + '-' + position + '-black';
    }

    // else create a new marker with the desired color

    else {
      var svg = d3.select("#pathway-container").select(function() {
        return this.contentDocument.documentElement;
      });

      var markerElementBlack = svg.select('marker#' + name + '-' + position + '-black');

      var markerElement = clone(markerElementBlack[0][0]);

      // define style of marker element

      var markerElementStyle = '';

      if (markerElement[0][0].getAttribute('stroke') === 'black') {
       markerElementStyle += 'stroke:' + color + '; ';
      };

      if (markerElement[0][0].getAttribute('fill') === 'black') {
       markerElementStyle += 'fill:' + color + '; ';
      };

      markerElement[0][0].setAttribute('id', name + '-' + position + '-' + color );
      markerElement[0][0].setAttribute('style', markerElementStyle);

      markerName = name + '-' + position + '-' + color;
    };
  };
  return markerName;
};

function getPathData(d) {
  var pathData = "";
  d.points.forEach(function(element, index, array) {
      if (index === 0) {
      pathData = "M " + element.x + " " + element.y; 
      }
      else {
      pathData += " L " + element.x + " " + element.y; 
      };
      return pathData;
      });
  return pathData;
};

function drawPathway() {
  d3.json("../../samples/gpml/all-elements.json",function(error, json) {
  //d3.json("../../samples/gpml/datanodeshapes.json",function(error, json) {
    if (error) return console.warn(error);
    data = json;
    //d3.xml("../../samples/gpml/WP673_63184.gpml", "application/xml", function(xml) {
    //d3.xml("../../samples/gpml/ovalandpentagon.gpml", "application/xml", function(xml) {

    console.log('GPML pathway');
    console.log(data);
    self.data = data;

    // be sure server has set gpml mime type to application/gpml+xml

    var pathway = data; //convertGpml2Json(xml);

    var drag = d3.behavior.drag()
    .on("drag", dragmove);

    function dragmove(d) {
      console.log(
        "x: " + d3.event.x + ", " + 
        "y: " + d3.event.y + ", " + 
        "dx: " + d3.event.dx + ", " + 
        "dy: " + d3.event.dy);
        d.x=d3.event.x;
        d.y=d3.event.y;
        d3.select(this)
        .attr("x", d3.event.x)
        .attr("y", d3.event.y);
    }	

    var svg = self.svg = d3.select("#pathway-container").select(function() {
      return this.getSVGDocument().documentElement;
    });

    svg.attr('width', pathway.boardWidth);
    svg.attr('height', pathway.boardHeight);

    var symbolsAvailable = svg.selectAll('symbol');
    var markersAvailable = svg.selectAll('marker');

    var pathwayNameText = svg.append('text')
    .attr("id", 'pathway-name-text')
    .attr("x", 80)
    .attr("y", 10)
    .text(function (d) { return 'Title: ' + pathway.name });

    var pathwayOrganismText = svg.append('text')
    .attr("id", 'pathway-organism-text')
    .attr("x", 80)
    .attr("y", 30)
    .text(function (d) { return 'Organism: ' + pathway.organism });

    // Draw Labelable Elements

    var labelableElementsContainer = svg.selectAll("g.labelable-elements-container")	
    .data(pathway.labelableElements)
    .enter()
    .append("g")
    .attr("id", function (d) { return 'labelable-elements-container-' + d.graphId })
    .attr('transform', function(d) { return 'translate(' + d.x + ' ' + d.y + ')'; })
    .attr("class", "labelable-elements-container")
    .call(drag);

    var labelableElements = labelableElementsContainer.each(function(d) {
      var labelableElement = d3.select(this).append('use')
      .attr("id", function (d) {return 'labelable-element-' + d["@GraphId"]})
      .attr('transform', function(d) { 
        var transform = 'none';
        if (d.hasOwnProperty('rotation')) {
          transform = 'rotate(' + d.rotation + ' ' + d.width / 2 + ' ' + d.height / 2 + ')';
        };
        return transform;
      })
      .attr("class", function (d) { 
        var styleClass = ''; 
        if (d.elementType === 'data-node') {
          styleClass = "labelable-element " + d.elementType + ' ' + d.dataNodeType; 
        }
        else {
          styleClass = "labelable-element " + d.elementType; 
        };
        if (d.hasOwnProperty('strokeStyle')) {
          if (d.strokeStyle === 'broken') {
            styleClass += " broken-stroke"; 
          };
          // TODO currently cannot render double lines for linestyles for labelableElements.
        };
        return styleClass })
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", function (d) { return d.width; })
        .attr("height", function (d) { return d.height; })
        .attr("z-index", function (d) { return d.zIndex; })
        .attr("style", function (d) { 
          var style = '';
          if (d.hasOwnProperty('fill')) {
            style = 'fill:' + d.fill + '; '; 
          };
          if (d.hasOwnProperty('stroke')) {
            style += 'stroke:' + d.stroke + '; '; 
          };
          if (d.hasOwnProperty('strokeWidth')) {
            style += 'stroke-width:' + d.strokeWidth + '; '; 
          };
          return style; 
        });

        if (symbolsAvailable.filter(function(d, i) { return (symbolsAvailable[0][i].id === pathway.labelableElements[0].symbolType); }).length > 0) {
          // d3 bug strips 'xlink' so need to say 'xlink:xlink';
          labelableElement.attr("xlink:xlink:href", function (d) {return "#" + d.symbolType; });
        }
        else {
          labelableElement.attr("xlink:xlink:href", "#rectangle");
          console.log('Pathvisio.js does not have access to the requested symbol: ' + pathway.labelableElements[0].symbolType + '. Rectangle used as placeholder.');
        };

        // use this for tspan option for rendering text, including multi-line

        if (d.hasOwnProperty('textLabel')) {
          var labelableElementText = d3.select(this).append('text')
          .attr("id", function (d) { return 'labelable-element-text-' + d.graphId; })
          .attr("x", 0)
          .attr("y", 0)
          .attr('transform', function(d) {
            if (d.textLabel.hasOwnProperty('textAnchor')) {

              // giving padding of 5. maybe this should go into the CSS.

              if (d.textLabel.textAnchor === 'start') {
                var dx = 5;
              }
              else {
                if (d.textLabel.textAnchor === 'end') {
                  var dx = d.width - 5;
                }
              };
            }
            else {
              var dx = d.width / 2;
            };
            var dy = (d.height / 2) + (0.3 * d.textLabel.fontSize) - (((splitTextByLines(d.textLabel.text).length - 1) * d.textLabel.fontSize)/2);
            console.log('splitTextByLines(d.textLabel.text).length');
            console.log(splitTextByLines(d.textLabel.text).length);
            return 'translate(' + dx + ' ' + dy + ')'; })
            .attr("class", function (d) { 
              var styleClass = ''; 
              if (d.elementType === 'data-node') {
                styleClass = "labelable-element " + d.elementType + ' ' + d.dataNodeType; 
              }
              else {
                styleClass = "labelable-element " + d.elementType; 
              };
              return styleClass })
              .attr("style", function (d) { 
                var style = '';
                var fontSize = d.fontSize;
                if (d.textLabel.hasOwnProperty('color')) {
                  style += 'fill:' + d.textLabel.color + '; '; 
                };
                if (d.textLabel.hasOwnProperty('fontFamily')) {
                  style += 'font-family:' + d.textLabel.fontFamily + '; '; 
                };
                if (d.textLabel.hasOwnProperty('fontSize')) {
                  style += 'font-size:' + d.textLabel.fontSize + '; '; 
                };
                if (d.textLabel.hasOwnProperty('fontWeight')) {
                  style += 'font-weight:' + d.textLabel.fontWeight + '; '; 
                };
                if (d.textLabel.hasOwnProperty('fontStyle')) {
                  style += 'font-style:' + d.textLabel.fontStyle + '; '; 
                };
                if (d.textLabel.hasOwnProperty('textAnchor')) {
                  style += 'text-anchor:' + d.textLabel.textAnchor + '; '; 
                };
                return style; 
              });

              var labelableElementTspan = labelableElementText.each(function(d) {
                var fontSize = d.textLabel.fontSize;
                d3.select(this).selectAll('tspan')
                .data(function (d) {
                  var textArray = splitTextByLines(d.textLabel.text);
                  return textArray;
                })
                .enter()
                .append('tspan')
                .attr("x", 0)
                .attr("y", function (d, i) { return i * fontSize; })
                .text(function (d) { return d; });
              });
        };

        /*

        // use this for foreignObject object option for rendering text, including multi-line

        if (d.hasOwnProperty('textLabel')) {
        var labelableElementSwitch = d3.select(this).append('switch');

        var labelableElementForeignObject = labelableElementSwitch.append('foreignObject') 
        //.attr("x", 0)
        //.attr("y", 0)
        .attr("width", function (d) { return d.width + 'px'; })
        .attr("height", function (d) { return d.height + 'px'; });

        var labelableElementBody = labelableElementForeignObject.append('xhtml:body') 
        .attr("xmlns", "http://www.w3.org/1999/xhtml")
        .attr("id", function (d) { return 'labelable-element-text-' + d.graphId; })
        .attr("style", function (d) { return 'height:' + d.height + 'px'; });

        var labelableElementLink = labelableElementBody.append('link') 
        .attr("rel", "stylesheet")
        .attr("href", "pathways.css")
        .attr("type", "text/css");

        var labelableElementOuter = labelableElementBody.append('div') 
        .attr("class", "outer") 
        .attr("style", function (d) { return 'height:' + d.height + 'px'; });

        var labelableElementP = labelableElementOuter.append('p') 
        .attr("style", function (d) { 
        var style = 'height:' + d.height + 'px; ';
        if (d.textLabel.hasOwnProperty('color')) {
        style += 'color:' + d.textLabel.color + '; '; 
        };
        if (d.textLabel.hasOwnProperty('fontWeight')) {
        style += 'font-weight:' + d.textLabel.fontWeight + '; '; 
        };
        if (d.textLabel.hasOwnProperty('fontStyle')) {
        style += 'font-style:' + d.textLabel.fontStyle + '; '; 
        };
        return style; 
        })
        .text(function (d) {
        var text = d.textLabel.text;
        return text; 
        })
        .attr("class", function (d) { 
        var styleClass = ''; 
        if (d.elementType === 'data-node') {
        styleClass = "labelable-element " + d.elementType + ' ' + d.dataNodeType; 
        }
        else {
        styleClass = "labelable-element " + d.elementType; 
        };
        return styleClass });

        var labelableElementText = labelableElementSwitch.append('text')
        .attr("id", function (d) { return 'labelable-element-text-' + d.graphId; })
        .attr("x", function (d) { return d.width / 2; })
        .attr("y", function (d) { return d.height / 2 + 0.3 * d.textLabel.fontSize; })
        //.attr("style", function (d) { return 'stroke:' + 'red'; })
        .attr("style", function (d) { 
        var style = '';
        if (d.textLabel.hasOwnProperty('color')) {
        style += 'fill:' + d.textLabel.color + '; '; 
        };
        if (d.textLabel.hasOwnProperty('fontWeight')) {
        style += 'font-weight:' + d.textLabel.fontWeight + '; '; 
        };
        if (d.textLabel.hasOwnProperty('fontStyle')) {
        style += 'font-style:' + d.textLabel.fontStyle + '; '; 
        };
        return style; 
  })
  .text(function (d) { return d.textLabel.text; });

  };
  */
    });

    // Interactions


    var pathData = null;

        var interactions = svg.selectAll("path.interaction")
        .data(pathway.interactions)
        .enter()
        .append("path")
        .attr("id", function (d) { return 'interaction-' + d.graphId; })
        .attr("class", "interaction")
        .attr("class", function (d) { 
          var styleClass = 'interaction ';
          if (d.hasOwnProperty('strokeStyle')) {
            if (d.strokeStyle === 'broken') {
              styleClass += " broken-stroke"; 
            };
          };
          return styleClass; 
        })
        .attr("d", function (d) {
          pathData = getPathData(d);
          if (d.hasOwnProperty('strokeStyle')) {
            if (d.strokeStyle === 'double') {

              // setting stroke-width equal to its specified line value is
              // what PathVisio (Java) does, but the white line (overlaying the
              // thick line to create a "double line") is hard to see at 1px.

              svg.append("path")
              .attr("class", "interaction-double")
              .attr("d", pathData)
              .attr("style", "stroke:white; stroke-width:" + d.strokeWidth + '; ')
              .attr("marker-start", 'url(#' + getMarker(d.markerStart, 'start', d.stroke) + ')')
              .attr("marker-end", 'url(#' + getMarker(d.markerEnd, 'end', d.stroke) + ')');
            };
          };
          return pathData; 
        })
        .attr("style", function (d) { 
          var style = 'stroke-width:' + d.strokeWidth + '; ';
          if (d.hasOwnProperty('stroke')) {
            style += 'stroke:' + d.stroke + '; '; 
          };
          if (d.hasOwnProperty('strokeStyle')) {
            if (d.strokeStyle === 'double') {
              style += 'stroke-width:' + (3 * d.strokeWidth) + '; '; 
            };
          };
          return style; 
        })
        .attr("marker-start", function (d) { 
          markerStart = getMarker(d.markerStart, 'start', d.stroke);
          if (d.hasOwnProperty('strokeStyle')) {
            if (d.strokeStyle === 'double') {
              markerStart = 'mim-gap-start-black';
            };
          };
          return 'url(#' + markerStart + ')'; 
        })
        .attr("marker-end", function (d) { 
          markerEnd = getMarker(d.markerEnd, 'end', d.stroke);
          if (d.hasOwnProperty('strokeStyle')) {
            if (d.strokeStyle === 'double') {
              markerEnd = 'mim-gap-end-black';
            };
          };
          return 'url(#' + markerEnd + ')'; 
        })
        .attr("fill", 'none');
  });
};
</script>
