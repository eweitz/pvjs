<!DOCTYPE html>
<meta charset="utf-8">
<title>pathvisio.js renderer</title>

<!-- 
Style guides can be arbitrary, but for sake of consistency within this project, let's use these:
http://google-styleguide.googlecode.com/svn/trunk/htmlcssguide.xml
http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml
http://google-styleguide.googlecode.com/svn/trunk/jsoncstyleguide.xml#General_Guidelines
-->

<script src="http://mbostock.github.com/d3/d3.js?1.27.1"></script>
<script src="../js/xml2json.js"></script>
<script src="../js/jxon.js"></script>
<script src="../js/jquery-1.9.1.js"></script>
<script src="../js/rgbcolor.js"></script>
<script src="http://code.jquery.com/jquery-latest.min.js"></script>
<style>
text {
  font-size: 200px;
  font-family: "arial";
}
</style>

<object id="pathway-container" data="pathwaydefs.svg" type="image/svg+xml" width="100%" height="100%" onload="drawPathway()"></object>

<script>
function convertToArray(object) {
  if (Object.prototype.toString.call( object ) === '[object Object]' ) {
    var array = [];
    array.push(object)
    return array;
  }
  else {
    if( Object.prototype.toString.call( object ) === '[object Array]' ) {
      return object;
    }
  }
}
function convertGpml2Json(xmlDoc){

  // GPML to jGPML mappings: { 'OldName':'new-name' }
  // replace spaces with dashes
  // Add dashes before every capital letter except any capital letters at the beginning of the string
  // Replace spaces with dashes
  // Replace double dashes with single dashes
  // replace capitals letters with lowercase. 

  // GPML to jGPML shape name mappings: { "oldName":"new-name" }

  var shapeMappings = { "Arc":"arc", "Brace":"brace",  "Rectangle":"rectangle", "RoundedRectangle":"rounded-rectangle", "Oval":"oval", "Endoplasmic Reticulum":"endoplasmic-reticulum", "Golgi Apparatus":"golgi-apparatus", "Mitochondria":"mitochondria", "Triangle":"triangle", "Pentagon":"pentagon", "Hexagon":"hexagon", "Sarcoplasmic Reticulum":"sarcoplasmic-reticulum", "mim-degradation":"mim-degradation" };

  // GPML to jGPML marker name mappings: { "oldName":"new-name" }
  // excludes mim-branching-left and mim-branching-right as per Alex Pico's request

  var markerMappings = { "Arrow":"arrow", "TBar":"t-bar", "mim-necessary-stimulation":"mim-necessary-stimulation", "mim-binding":"mim-binding", "mim-conversion":"mim-conversion", "mim-stimulation":"mim-stimulation", "mim-modification":"mim-modification", "mim-catalysis":"mim-catalysis", "mim-inhibition":"mim-inhibition", "mim-cleavage":"mim-cleavage", "mim-covalent-bond":"mim-covalent-bond", "mim-transcription-translation":"mim-transcription-translation", "mim-gap":"mim-gap" };

  var dataNodeTypeMappings = { 'GeneProduct':'gene-product',  'Metabolite':'metabolite', 'Pathway':'pathway', 'Protein':'protein', 'Unknown':'unknown' };

  console.log('xmlDoc');
  console.log(xmlDoc);

  // We can use xml2json.js or JXON.js. Which is better?
  // JXON.js
     var parsedJson = self.parsedJson = {};
     pathway = JXON.build(xmlDoc.documentElement);
  try {
    xmlns = pathway["xmlns"]
  }
  catch (e) {
    console.log(e.message);
    return;
  }

  // test for whether file is GPML based on xmlns without reference to version

  var gpmlXmlnsSupported = "http://pathvisio.org/GPML/2013a";
  var gpmlXmlnsIdentifier = "/GPML/";

  // current and previous GPML xmlns values
  // "http://pathvisio.org/GPML/2013a"
  // "http://genmapp.org/GPML/2010a"
  // "http://genmapp.org/GPML/2008a"
  // "http://genmapp.org/GPML/2007"

  if ( xmlns.indexOf(gpmlXmlnsIdentifier) !== -1 ) {

    // test for whether the GPML file version matches the current version supported by pathvisio.js

    if (xmlns != gpmlXmlnsSupported) {

      // preferably, this would call the Java RPC updater for the file to be updated.

      alert("Pathvisio.js may not fully support the version of GPML provided (xmlns: " + xmlns + "). Please convert to the supported version of GPML (xmlns: " + gpmlXmlnsSupported + ").")
    }

    // Convert output from xml2json into well-formed JSON.
    // It would be better to do this in the conversion file xml2json.js.

    pathway.boardWidth = pathway.graphics.boardwidth;
    pathway.boardHeight = pathway.graphics.boardheight;
    delete pathway.graphics;

    // infoBox

    pathway.infoBox = pathway.infobox;
    delete pathway.infobox;

    // what should these values actually be?

    pathway.infoBox.x = pathway.infoBox.centerx;
    delete pathway.infoBox.centerx;
    pathway.infoBox.y = pathway.infoBox.centery;
    delete pathway.infoBox.centery;

    // BiopaxRefs

    try {
      pathway.biopaxRefs = convertToArray( pathway.biopaxref );
      delete pathway.biopaxref;

      pathway.biopaxRefs.forEach(function(element, index, array) {
        // modify data
      });
    }
    catch (e) {
      console.log("No BiopaxRefs found.");
    }

    // Comments 

    try {
      pathway.comments = convertToArray( pathway.comment );
      delete pathway.comment;

      pathway.comments.forEach(function(element, index, array) {

        // modify data

      });
    }
    catch (e) {
      console.log("No Comments found.");
    }

    // LabelableElements
   
    pathway.labelableElements = [];

    function parseLabelableElement(element, index, array, elementType) {
        element.graphId = element.graphid;
        delete element.graphid;

        if (element.hasOwnProperty('comment')) {
          element.comments = convertToArray( element.comment );
          delete element.comment;
        };

        element.x = parseFloat(element.graphics.centerx) - parseFloat(element.graphics.width)/2;
        element.x = Math.round( element.x * 100 ) / 100;

        element.y = parseFloat(element.graphics.centery) - parseFloat(element.graphics.height)/2;
        element.y = Math.round( element.y * 100 ) / 100;

        element.width = parseFloat(element.graphics.width);
        element.width = Math.round( element.width * 100 ) / 100;

        element.height = parseFloat(element.graphics.height);
        element.height = Math.round( element.height * 100 ) / 100;

        // If unspecified due to being default, should we set the styles for stroke, fill and font-name here or in CSS?
        // Currently, every default value that can be specified in the CSS is not specified in the code below.

        if (element.graphics.hasOwnProperty("fillcolor")) {
          // RGBColor() from http://www.phpied.com/rgb-color-parser-in-javascript/
          // license: Use it if you like it
          var fill = new RGBColor(element.graphics.fillcolor);
          if (fill.ok) { 
            element.fill = fill.toHex();
          }
        };

        if (element.graphics.hasOwnProperty("color")) {
          var color = new RGBColor(element.graphics.color);
          if (color.ok) { 
            element.stroke = color.toHex();
          }
        };	

        if (element.graphics.hasOwnProperty("linethickness")) {
          element.strokeWidth = element.graphics.linethickness;
        };	

        if (element.graphics.hasOwnProperty('linestyle')) {
          element.strokeStyle = element.graphics.linestyle.toLowerCase();
          delete element.graphics.linestyle;
        }	
        else {
          if (element.hasOwnProperty('attribute')) {
            if ((element.attribute.key === "org.pathvisio.DoubleLineProperty") && (element.attribute.value === "Double")) {
              element.strokeStyle = 'double';
              delete element.attribute;
            };
          };	
        };

        if (element.graphics.hasOwnProperty("rotation")) {

          // get rotation in degrees because SVG rotate attribute uses degrees
          // http://www.w3.org/TR/SVG/coords.html#TransformAttribute

          element.rotation = element.graphics.rotation * (180 / Math.PI);
          element.rotation = Math.round( element.rotation * 100 ) / 100;
        };	

        // textLabel data

        if (element.hasOwnProperty("textlabel")) {
          element.textLabel = {"text":element.textlabel};
          delete element.textlabel;

          if (element.graphics.hasOwnProperty("color")) {
            // element stroke and text color appear to be the same property in the Java PathVisio code
            element.textLabel.color = element.stroke;
          };	

          if (element.graphics.hasOwnProperty("fontsize")) {
            element.textLabel.fontSize = element.graphics.fontsize;
          };

          if (element.graphics.hasOwnProperty("fontname")) {
            element.textLabel.fontFamily = element.graphics.fontname;
          };

          if (element.graphics.hasOwnProperty("fontweight")) {
            element.textLabel.fontWeight = element.graphics.fontweight.toLowerCase();
          };

          if (element.graphics.hasOwnProperty("fontstyle")) {
            element.textLabel.fontStyle = element.graphics.fontstyle.toLowerCase();
          };
        }

        if ((!(element.graphics.hasOwnProperty("shapetype"))) || (element.graphics.shapetype === 'Rectangle')) {
          element.symbolType = "rectangle";
        }
        else {
          element.symbolType = shapeMappings[element.graphics.shapetype];
        };	

        delete element.graphics;

        element.elementType = elementType;

        if (elementType === 'data-node') {
          if (dataNodeTypeMappings.hasOwnProperty(element.type)) {
            element.dataNodeType = dataNodeTypeMappings[element.type];
          }
          else {
            element.dataNodeType = element.type;
          };
          delete element.type;

          if (element.hasOwnProperty('xref')) {
            element.xRef = element.xref;
            delete element.xref;
          };
        };

        pathway.labelableElements.push(element);
        delete element.graphics;
    };

    // DataNodes 

    try {
      pathway.dataNodes = convertToArray( pathway.datanode );
      delete pathway.datanode;

      pathway.dataNodes.forEach(function(element, index, array) {
        parseLabelableElement(element, index, array, 'data-node');
      });

      delete pathway.dataNodes;

    }
    catch (e) {
      console.log("No DataNodes found.");
    }

    // Groups

    try {
      pathway.groups = convertToArray( pathway.group );
      delete pathway.group;

      pathway.groups.forEach(function(element, index, array) {

        element.graphId = element.graphid;
        delete element.graphid;

        element.groupId = element.groupid;
        delete element.groupid;

      });
    }
    catch (e) {
      console.log("No Groups found.");
    }

    // Interactions

    try {
      pathway.interactions = convertToArray( pathway.interaction );
      delete pathway.interaction;

      pathway.interactions.forEach(function(element, index, array) {

        element.graphId = element.graphid;
        delete element.graphid;

        if (element.graphics.hasOwnProperty('color')) {
          var color = new RGBColor(element.graphics.color);
          if (color.ok) { 
            element.stroke = color.toHex();
          }
        };	

        element.strokeWidth = element.graphics.linethickness;

        if (element.graphics.hasOwnProperty('linestyle')) {
          element.strokeStyle = element.graphics.linestyle.toLowerCase();
          delete element.graphics.linestyle;
        }	
        else {
          if (element.hasOwnProperty('attribute')) {
            if ((element.attribute.key === "org.pathvisio.DoubleLineProperty") && (element.attribute.value === "Double")) {
              element.strokeStyle = 'double';
              delete element.attribute;
            };
          };	
        };

        element.zIndex = element.graphics.zorder;
        delete element.graphics.zorder;

        element.xRef = element.xref;
        delete element.xref;

        var markerStart = 'none';
        var markerEnd = 'none';

        // Points

        element.points = convertToArray( element.graphics.point );
        delete element.graphics;

        element.points.forEach(function(element, index, array) {

          element.graphRef = element.graphref;
          delete element.graphref;

          // This is probably unreliable. We need to establish a way to ensure we identify start and end markers correctly, and we should not rely on the order of elements in XML.

          if ((index === 0) && (markerMappings.hasOwnProperty(element.arrowhead))) {
              markerStart = markerMappings[element.arrowhead];
              delete element.arrowhead;
          }
          else {
            if ((index === array.length - 1) && (markerMappings.hasOwnProperty(element.arrowhead))) {
              markerEnd = markerMappings[element.arrowhead];
              delete element.arrowhead;
            }
          };
        });

        // Back to interactions
        // TODO This could be refactored for maintainability and speed.

        if (markerStart === 'none') {
          element.markerStart = markerStart;
        }
        else {

          // if it's black, use the default

          if ( (element.stroke === '#000') || (element.stroke === '#000000') || (!(element.stroke)) ) {
            element.markerStart = markerStart + '-start-black';
          }

          // else create a new marker with the desired color

          else {
            var svg = d3.select("#pathway-container").select(function() {
              return this.contentDocument.documentElement;
            });

            var markerElementBlack = svg.select('marker#' + markerStart + '-start-black');

            var markerElement = clone(markerElementBlack[0][0]);

            // define style of marker element

            var markerElementStyle = '';

            if (markerElement[0][0].getAttribute('stroke') === 'black') {
             markerElementStyle += 'stroke:' + element.stroke + '; ';
            };

            if (markerElement[0][0].getAttribute('fill') === 'black') {
             markerElementStyle += 'fill:' + element.stroke + '; ';
            };

            markerElement[0][0].setAttribute('id', markerStart + '-start-' + element.stroke );
            markerElement[0][0].setAttribute('style', markerElementStyle);

            element.markerStart = markerStart + '-start-' + element.stroke;
          };
        };

        if (markerEnd === 'none') {
          element.markerEnd = markerEnd;
        }
        else {

          // if it's black, use the default

          if ( (element.stroke === '#000') || (element.stroke === '#000000') || (!(element.stroke)) ) {
            element.markerEnd = markerEnd + '-end-black';
          }

          // else create a new marker with the desired color

          else {
            var svg = d3.select("#pathway-container").select(function() {
              return this.contentDocument.documentElement;
            });

            var markerElementBlack = svg.select('marker#' + markerEnd + '-end-black');

            var markerElement = clone(markerElementBlack[0][0]);

            // define style of marker element

            var markerElementStyle = '';

            if (markerElement[0][0].getAttribute('stroke') === 'black') {
             markerElementStyle += 'stroke:' + element.stroke + '; ';
            };

            if (markerElement[0][0].getAttribute('fill') === 'black') {
             markerElementStyle += 'fill:' + element.stroke + '; ';
            };

            markerElement[0][0].setAttribute('id', markerEnd + '-end-' + element.stroke );
            markerElement[0][0].setAttribute('style', markerElementStyle);

            element.markerEnd = markerEnd + '-end-' + element.stroke;
          };
        };


        delete element.graphics;

      });
    }
    catch (e) {
      console.log(e + "No Interactions found.");
    }

    // Labels

    try {
      pathway.labels = convertToArray( pathway.label );
      delete pathway.label;

      pathway.labels.forEach(function(element, index, array) {
        parseLabelableElement(element, index, array, 'label');
      });

      delete pathway.labels;
    }
    catch (e) {
      console.log("No Labels found.");
    }

    // Shapes

    try {
      pathway.shapes = convertToArray( pathway.shape );
      delete pathway.shape;

      pathway.shapes.forEach(function(element, index, array) {
        parseLabelableElement(element, index, array, 'shape');
      });

      delete pathway.shapes;
    }
    catch (e) {
      console.log("No Shapes found.");
    }

    console.log('pathway');
    console.log(pathway);
    return pathway;
  }
  else {
    alert("Pathvisio.js does not support the data format provided. Please convert to GPML and retry.")
    console.log("Pathvisio.js does not support the data format provided. Please convert to GPML and retry.")
    return;
  }
};

function clone(selector) {
  var node = d3.select(selector).node();
  return d3.select(node.parentNode.insertBefore(node.cloneNode(true), node.nextSibling));
};

function drawPathway() {
        d3.xml("../../samples/gpml/DatanodeShapes1.gpml", "application/xml", function(xml) {
        //d3.xml("../../samples/gpml/WP673_63184.gpml", "application/xml", function(xml) {
         //d3.xml("../../samples/gpml/ovalandpentagon.gpml", "application/xml", function(xml) {
          var pathway = convertGpml2Json(xml);
          console.log(pathwayc = pathway);

          var drag = d3.behavior.drag()
          .on("drag", dragmove);

          function dragmove(d) {
            console.log(
              "x: " + d3.event.x + ", " + 
              "y: " + d3.event.y + ", " + 
              "dx: " + d3.event.dx + ", " + 
              "dy: " + d3.event.dy);
              d.x=d3.event.x;
              d.y=d3.event.y;
              d3.select(this)
              .attr("x", d3.event.x)
              .attr("y", d3.event.y);
          }	

          var svg = self.svg = d3.select("#pathway-container").select(function() {
            var svgObject = self.svgObject = this;
            console.log(svgObject);
            var svgContentDocument = self.svgContentDocument = this.getSVGDocument();
            console.log(svgContentDocument);
            var svgInside = self.svgInside = this.getSVGDocument().documentElement; 
            console.log(svgInside);
            return this.getSVGDocument().documentElement;
          });

          svg.attr('width', pathway.boardWidth);
          svg.attr('height', pathway.boardHeight);

          console.log('svg');
          console.log(svg);

          var symbolsAvailable = svg.selectAll('symbol');
          var markersAvailable = svg.selectAll('marker');

          var pathwayNameText = svg.append('text')
          .attr("id", 'pathway-name-text')
          .attr("x", 80)
          .attr("y", 10)
          .text(function (d) { return 'Title: ' + pathway.name });

          var pathwayOrganismText = svg.append('text')
          .attr("id", 'pathway-organism-text')
          .attr("x", 80)
          .attr("y", 30)
          .text(function (d) { return 'Organism: ' + pathway.organism });

          // Draw Labelable Elements

          var labelableElementsContainer = svg.selectAll("g.labelable-elements-container")	
          .data(pathway.labelableElements)
          .enter()
          .append("g")
          .attr("id", function (d) { return 'labelable-elements-container-' + d.graphId })
          .attr('transform', function(d) { return 'translate(' + d.x + ' ' + d.y + ')'; })
          .attr("class", "labelable-elements-container")
          .call(drag);

          var labelableElements = labelableElementsContainer.each(function(d) {
            var labelableElement = d3.select(this).append('use')
            .attr("id", function (d) {return 'labelable-element-' + d["@GraphId"]})
            .attr('transform', function(d) { 
              var transform = 'none';
              if (d.hasOwnProperty('rotation')) {
                transform = 'rotate(' + d.rotation + ' ' + d.width / 2 + ' ' + d.height / 2 + ')';
              };
              return transform;
            })
            .attr("class", function (d) { 
              var styleClass = ''; 
              if (d.elementType === 'data-node') {
                styleClass = "labelable-element " + d.elementType + ' ' + d.dataNodeType; 
              }
              else {
                styleClass = "labelable-element " + d.elementType; 
              };
              if (d.hasOwnProperty('strokeStyle')) {
                if (d.strokeStyle === 'broken') {
                  styleClass += " broken-stroke"; 
                };
                // TODO currently cannot render double lines for linestyles for labelableElements.
              };
              return styleClass })
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", function (d) { return d.width; })
            .attr("height", function (d) { return d.height; })
            .attr("z-index", function (d) { return d.zIndex; })
            .attr("style", function (d) { 
                var style = '';
                if (d.hasOwnProperty('fill')) {
                    style = 'fill:' + d.fill + '; '; 
                };
                if (d.hasOwnProperty('stroke')) {
                    style += 'stroke:' + d.stroke + '; '; 
                };
                if (d.hasOwnProperty('strokeWidth')) {
                    style += 'stroke-width:' + d.strokeWidth + '; '; 
                };
                return style; 
                });

            if (symbolsAvailable.filter(function(d, i) { return (symbolsAvailable[0][i].id === pathway.labelableElements[0].symbolType); }).length > 0) {
              // d3 bug strips 'xlink' so need to say 'xlink:xlink';
              labelableElement.attr("xlink:xlink:href", function (d) {return "#" + d.symbolType; });
            }
            else {
              labelableElement.attr("xlink:xlink:href", "#rectangle");
              console.log('Pathvisio.js does not have access to the requested symbol: ' + pathway.labelableElements[0].symbolType + '. Rectangle used as placeholder.');
            };

            /*
            if (d.hasOwnProperty('textLabel')) {
              var labelableElementText = d3.select(this).append('text')
              .attr("id", function (d) { return 'labelable-element-text-' + d.graphId; })
              .attr("x", function (d) { return d.width / 2; })
              .attr("y", function (d) { return d.height / 2 + 0.3 * d.textLabel.fontSize; })
              //.attr("style", function (d) { return 'stroke:' + 'red'; })
                .attr("style", function (d) { 
                    var style = '';
                    if (d.textLabel.hasOwnProperty('fill')) {
                        style = 'fill:' + d.textLabel.color + '; '; 
                    };
                    return style; 
                    })
              .text(function (d) { return d.textLabel.text; });
            };
            */

            if (d.hasOwnProperty('textLabel')) {
              var labelableElementSwitch = d3.select(this).append('switch');
              
              var labelableElementForeignObject = labelableElementSwitch.append('foreignObject') 
              //.attr("x", 0)
              //.attr("y", 0)
              .attr("width", function (d) { return d.width + 'px'; })
              .attr("height", function (d) { return d.height + 'px'; });

              var labelableElementBody = labelableElementForeignObject.append('xhtml:body') 
              .attr("xmlns", "http://www.w3.org/1999/xhtml")
              .attr("id", function (d) { return 'labelable-element-text-' + d.graphId; })
              .attr("style", function (d) { return 'height:' + d.height + 'px'; });

              var labelableElementLink = labelableElementBody.append('link') 
              .attr("rel", "stylesheet")
              .attr("href", "pathways.css")
              .attr("type", "text/css");

              var labelableElementOuter = labelableElementBody.append('div') 
              .attr("class", "outer") 
              .attr("style", function (d) { return 'height:' + d.height + 'px'; });

              var labelableElementP = labelableElementOuter.append('p') 
              .attr("style", function (d) { 
                  var style = 'height:' + d.height + 'px; ';
                  if (d.textLabel.hasOwnProperty('color')) {
                      style += 'color:' + d.textLabel.color + '; '; 
                  };
                  if (d.textLabel.hasOwnProperty('fontWeight')) {
                      style += 'font-weight:' + d.textLabel.fontWeight + '; '; 
                  };
                  if (d.textLabel.hasOwnProperty('fontStyle')) {
                      style += 'font-style:' + d.textLabel.fontStyle + '; '; 
                  };
                  return style; 
                  })
              .text(function (d) {
                var text = d.textLabel.text;
                return text; 
              })
              .attr("class", function (d) { 
                var styleClass = ''; 
                if (d.elementType === 'data-node') {
                  styleClass = "labelable-element " + d.elementType + ' ' + d.dataNodeType; 
                }
                else {
                  styleClass = "labelable-element " + d.elementType; 
                };
                return styleClass });

              var labelableElementText = labelableElementSwitch.append('text')
              .attr("id", function (d) { return 'labelable-element-text-' + d.graphId; })
              .attr("x", function (d) { return d.width / 2; })
              .attr("y", function (d) { return d.height / 2 + 0.3 * d.textLabel.fontSize; })
              //.attr("style", function (d) { return 'stroke:' + 'red'; })
                .attr("style", function (d) { 
                    var style = '';
                    if (d.textLabel.hasOwnProperty('color')) {
                        style += 'fill:' + d.textLabel.color + '; '; 
                    };
                  if (d.textLabel.hasOwnProperty('fontWeight')) {
                      style += 'font-weight:' + d.textLabel.fontWeight + '; '; 
                  };
                  if (d.textLabel.hasOwnProperty('fontStyle')) {
                      style += 'font-style:' + d.textLabel.fontStyle + '; '; 
                  };
                    return style; 
                    })
              .text(function (d) { return d.textLabel.text; });

            };
          });

        // Interactions

          function getMarkers(d) {
            var marker = {};
            marker.start = null;
            marker.end = null;
            d.points.forEach(function(element, index, array) {
              if ((element.position === 'start') && (element.hasOwnProperty('marker'))) {
                if (markersAvailable.filter(function(d, i) { return (markersAvailable[0][i].id === element.marker + '-start-black'); }).length > 0) {
                  marker.start = element.marker + '-start-black'; 
                }
                else {
                  console.log('Pathvisio.js does not have access to the requested marker: ' + element.marker + '. Arrow used as placeholder.');
                  marker.start = element.marker + 'arrow-start-black'; 
                };
              }
              else {
                if ((element.position === 'end') && (element.hasOwnProperty('marker'))) {
                  if (markersAvailable.filter(function(d, i) { return (markersAvailable[0][i].id === element.marker + '-end-black'); }).length > 0) {
                    marker.end = element.marker + '-end-black'; 
                  }
                  else {
                    console.log('Pathvisio.js does not have access to the requested marker: ' + element.marker + '. Arrow used as placeholder.');
                    marker.end = element.marker + 'arrow-end-black'; 
                  };
                }
              };
              return marker;
            });
            return marker;
          };

          function getPathData(d) {
            var pathData = "";
            d.points.forEach(function(element, index, array) {
              if (index === 0) {
                pathData = "M " + element.x + " " + element.y; 
              }
              else {
                pathData += " L " + element.x + " " + element.y; 
              };
              return pathData;
            });
            return pathData;
          };

          var pathData = null;

          var interactions = svg.selectAll("path.interaction")
          .data(pathway.interactions)
          .enter()
          .append("path")
          .attr("id", function (d) { return 'interaction-' + d.graphId; })
          .attr("class", "interaction")
          .attr("class", function (d) { 
            var styleClass = 'interaction ';
            if (d.hasOwnProperty('strokeStyle')) {
              if (d.strokeStyle === 'broken') {
                styleClass += " broken-stroke"; 
              };
            };
            return styleClass; 
          })
          .attr("d", function (d) {
            console.log('d');
            console.log(d);
            pathData = getPathData(d);
            if (d.hasOwnProperty('strokeStyle')) {
              if (d.strokeStyle === 'double') {
                
                // setting stroke-width equal to its specified line value is
                // what PathVisio (Java) does, but the white line (overlaying the
                // thick line to create a "double line") is hard to see at 1px.

                svg.append("path")
                .attr("class", "interaction-double")
                .attr("d", pathData)
                .attr("style", "stroke:white; stroke-width:" + d.strokeWidth + '; ')
                .attr("marker-start", 'url(#' + d.markerStart + ')')
                .attr("marker-end", 'url(#' + d.markerEnd + ')');
              };
            };
            return pathData; 
          })
          .attr("style", function (d) { 
            var style = 'stroke-width:' + d.strokeWidth + '; ';
            if (d.hasOwnProperty('stroke')) {
                style += 'stroke:' + d.stroke + '; '; 
            };
            if (d.hasOwnProperty('strokeStyle')) {
              if (d.strokeStyle === 'double') {
                style += 'stroke-width:' + (3 * d.strokeWidth) + '; '; 
              };
            };
            return style; 
            })
          .attr("marker-start", function (d) { 
            markerStart = d.markerStart;
            if (d.hasOwnProperty('strokeStyle')) {
              if (d.strokeStyle === 'double') {
                markerStart = 'mim-gap-start-black';
              };
            };
            return 'url(#' + markerStart + ')'; 
          })
          .attr("marker-end", function (d) { 
            markerEnd = d.markerEnd;
            if (d.hasOwnProperty('strokeStyle')) {
              if (d.strokeStyle === 'double') {
                markerEnd = 'mim-gap-end-black';
              };
            };
            return 'url(#' + markerEnd + ')'; 
          })
          .attr("fill", 'none');

          //.attr("x", d.x = d3.event.x)
          //.attr("y", d.y = d3.event.y);

        });
/*
// If users want to use pathvisio.js from another domain without copying over the full source,
// they will need to be able to access pathwayDefs.svg from a non-WikiPathways domain. For widget
// functionality, an iframe would suffice. For example, cross-origin policy would block 
// pathwayDefs.svg from being loaded for visitors accessing 
// http://127.0.0.1/~andersriutta/d3-from-gpml-using-defs/pathway-from-defs.html,
// but with an iframe, as in example at ./iframeWidget.html, pathwayDefs.svg would be on the same
// origin as the script request.
// To provide this, replace the appropriate line below with this line:
d3.xml("http://192.168.42.84/~andersriutta/d3-from-gpml-using-defs/pathwayDefs.svg", "image/svg+xml", function(xml) {

// If we wanted to request pathwayDefs.svg with a GET request, we could use JSONP, but
// this would require changing server side settings. For more informatiion, see:
// http://stackoverflow.com/questions/1678214/javascript-how-do-i-create-jsonp

$.ajax({
type: "GET",
url: "http://192.168.42.84/~andersriutta/d3-from-gpml-using-defs/pathwayDefs.svg",
dataType: "jsonp text",
success: function(xmlResponse) {
// process data 
console.log(xmlResponse);
}
});

// It would also be possible to recreate pathwayDefs.svg using d3.js. I'm not sure is faster:
// downloading an already created pathwayDefs.svg or drawing it with d3. This is something to
// test later on.

// One of the big benefits of using pathwayDefs.svg is that editing the SVG is probably more
// accessible for maintainability than editing the d3 code (if pathwayDefs.svg were created
// using d3). It would be possible to do both: download pathwayDefs.svg if on WikiPathways.org
// domain or recreate it with d3 if not. Is it possible to create d3 code from an existing
// svg?
 */

};
</script>
