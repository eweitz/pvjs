<!DOCTYPE html>
<meta charset="utf-8">
<title>pathvisio.js renderer</title>

<!-- 
Style guides can be arbitrary, but for sake of consistency within this project, let's use these:
http://google-styleguide.googlecode.com/svn/trunk/htmlcssguide.xml
http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml
http://google-styleguide.googlecode.com/svn/trunk/jsoncstyleguide.xml#General_Guidelines
-->

<script src="http://mbostock.github.com/d3/d3.js?1.27.1"></script>
<script src="../js/xml2json.js"></script>
<script src="../js/jquery-1.9.1.js"></script>
<style>
text {
  font-size: 200px;
  font-family: "arial";
}
</style>
<script src="http://code.jquery.com/jquery-latest.min.js"></script>

<object id="pathway-container" data="pathwaydefs.svg" type="image/svg+xml" width="100%" height="1000"></object>

<script>
function convertToArray(object) {
  if (Object.prototype.toString.call( object ) === '[object Object]' ) {
    var array = [];
    array.push(object)
    return array;
  }
  else {
    if( Object.prototype.toString.call( object ) === '[object Array]' ) {
      return object;
    }
  }
}
function convertGpml2Json(xmlDoc){

  // GPML to jGPML mappings: { 'oldName':'new-name' }
  // replace spaces with dashes
  // Add dashes before every capital letter except any capital letters at the beginning of the string
  // Replace spaces with dashes
  // Replace double dashes with single dashes
  // replace capitals letters with lowercase. 

  // GPML to jGPML shape name mappings: { "oldName":"new-name" }

  var shapeMappings = { "Brace":"brace",  "Rectangle":"rectangle", "RoundedRectangle":"rounded-rectangle", "Oval":"oval", "Endoplasmic Reticulum":"endoplasmic-reticulum", "Golgi Apparatus":"golgi-apparatus", "Mitochondria":"mitochondria", "Triangle":"triangle", "Pentagon":"pentagon", "Hexagon":"hexagon", "Sarcoplasmic Reticulum":"sarcoplasmic-reticulum" };

  // GPML to jGPML marker name mappings: { "oldName":"new-name" }

  var markerMappings = { "Arrow":"arrow", "TBar":"tbar", "mim-necessary-stimulation":"mim-necessary-stimulation", "mim-binding":"mim-binding", "mim-conversion":"mim-conversion", "mim-stimulation":"mim-stimulation", "mim-modification":"mim-modification", "mim-catalysis":"mim-catalysis", "mim-inhibition":"mim-inhibition", "mim-cleavage":"mim-cleavage", "mim-covalent-bond":"mim-covalent-bond", "mim-branching-left":"mim-branching-left", "mim-branching-right":"mim-branching-right", "mim-transcription-translation":"mim-transcription-translation", "mim-gap":"mim-gap" };

  console.log('xmlDoc');
  console.log(xmlDoc);

  // We can use xml2json.js or JXON.js. Which is better?
  // JXON.js
  /*
     var parsedJson = {};
     parsedJson.Pathway = JXON.build(xmlDoc.documentElement);
   */

  // xml2json.js

  var json = xml2json(xmlDoc, "");
  var parsedJson = JSON.parse(json);
  var xmlns = "";

  try {
    xmlns = parsedJson.Pathway["@xmlns"]
  }
  catch (e) {
    console.log(e.message);
    return;
  }

  // test for whether file is GPML based on xmlns without reference to version

  var gpmlXmlnsSupported = "http://pathvisio.org/GPML/2013a";
  var gpmlXmlnsIdentifier = "/GPML/";

  // current and previous GPML xmlns values
  // "http://pathvisio.org/GPML/2013a"
  // "http://genmapp.org/GPML/2010a"
  // "http://genmapp.org/GPML/2008a"
  // "http://genmapp.org/GPML/2007"

  if ( xmlns.indexOf(gpmlXmlnsIdentifier) !== -1 ) {

    // test for whether the GPML file version matches the current version supported by pathvisio.js

    if (xmlns != gpmlXmlnsSupported) {

      // preferably, this would call the Java RPC updater for the file to be updated.

      alert("Pathvisio.js may not fully support the version of GPML provided (xmlns: " + xmlns + "). Please convert to the supported version of GPML (xmlns: " + gpmlXmlnsSupported + ").")
    }

    // Convert output from xml2json into well-formed JSON.
    // It would be better to do this in the conversion file xml2json.js.

    // BiopaxRefs

    try {
      parsedJson.Pathway.BiopaxRefs = convertToArray( parsedJson.Pathway.BiopaxRef );
      delete parsedJson.Pathway.BiopaxRef;

      parsedJson.Pathway.BiopaxRefs.forEach(function(element, index, array) {
        // modify data
      });
    }
    catch (e) {
      console.log("No BiopaxRefs found.");
    }

    // Comments 

    try {
      parsedJson.Pathway.Comments = convertToArray( parsedJson.Pathway.Comment );
      delete parsedJson.Pathway.Comment;

      parsedJson.Pathway.Comments.forEach(function(element, index, array) {

        // modify data

      });
    }
    catch (e) {
      console.log("No Comments found.");
    }

    // DataNodes 

    try {
      parsedJson.Pathway.DataNodes = convertToArray( parsedJson.Pathway.DataNode );
      delete parsedJson.Pathway.DataNode;

      parsedJson.Pathway.DataNodes.forEach(function(element, index, array) {
        element.Graphics["x"] = parseFloat(element.Graphics["@CenterX"]) - parseFloat(element.Graphics["@Width"])/2;
        element.Graphics["y"] = parseFloat(element.Graphics["@CenterY"]) - parseFloat(element.Graphics["@Height"])/2;
        delete element.Graphics["@CenterX"];
        delete element.Graphics["@CenterY"];

        element.Graphics["@Width"] = parseFloat(element.Graphics["@Width"]);
        element.Graphics["@Height"] = parseFloat(element.Graphics["@Height"]);

        /*
           // If unspecified due to being default, should we set the styles for stroke, fill and font-name here or in CSS?

        if (element.Graphics.hasOwnProperty("@FillColor")) {

          // does not deal with color if user entered "white". Should use validateColor() to address.

          element.Graphics["@FillColor"] = "#" + element.Graphics["@FillColor"]
        }
        else {
          element.Graphics['@FillColor'] = "#ffffff";
        };

        if (element.Graphics.hasOwnProperty("@Color")) {
          element.Graphics["@Color"] = "#" + element.Graphics["@Color"]
        }
        else {
          element.Graphics['@Color'] = "#000000";
        };	

        if (!(element.Graphics.hasOwnProperty("@FontName"))) {
          element.Graphics['@FontName'] = "arial";
        };	
        */

        if ((!(element.Graphics.hasOwnProperty("@ShapeType"))) || (element.Graphics["@ShapeType"] === 'Rectangle')) {
          console.log(element.Graphics["@ShapeType"]);
          element.Graphics["@ShapeType"] = "rectangle";
        }
        else {
          if (shapeMappings.hasOwnProperty(element.Graphics["@ShapeType"])) {
            element.Graphics['@ShapeType'] = shapeMappings[element.Graphics['@ShapeType']];
          }
        };	

        // GPML to jGPML type name mappings: { 'oldName':'new-name' }

        var typeMappings = { 'GeneProduct':'gene-product',  'Metabolite':'metabolite', 'Pathway':'pathway', 'Protein':'protein', 'Unknown':'unknown' };
        if (typeMappings.hasOwnProperty(element["@Type"])) {
          element["@Type"] = typeMappings[element["@Type"]];
        }

      });
    }
    catch (e) {
      console.log("No DataNodes found.");
    }

    // Groups

    try {
      parsedJson.Pathway.Groups = convertToArray( parsedJson.Pathway.Group );
      delete parsedJson.Pathway.Group;

      parsedJson.Pathway.Groups.forEach(function(element, index, array) {

        // modify data

      });
    }
    catch (e) {
      console.log("No Groups found.");
    }

    // Interactions

    try {
      parsedJson.Pathway.Interactions = convertToArray( parsedJson.Pathway.Interaction );
      delete parsedJson.Pathway.Interaction;

      parsedJson.Pathway.Interactions.forEach(function(element, index, array) {
        element.Graphics.Points = convertToArray( element.Graphics.Point );
        delete element.Graphics.Point;

        element.Graphics.Points.forEach(function(element, index, array) {


          // This is probably unreliable. We need to establish a way to ensure we identify start and end markers correctly, and we should not rely on the order of elements in XML.

          if (index === 0) {
            element.position = 'start';
          }
          else {
            if (index === array.length - 1) {
              element.position = 'end';
            }
          };

          if (markerMappings.hasOwnProperty(element["@ArrowHead"])) {
            element.marker = markerMappings[element['@ArrowHead']];
            delete element["@ArrowHead"];
          };	

        });
      });
    }
    catch (e) {
      console.log("No Interactions found.");
    }

    // Labels

    try {
      parsedJson.Pathway.Labels = convertToArray( parsedJson.Pathway.Label );
      delete parsedJson.Pathway.Label;

      parsedJson.Pathway.Labels.forEach(function(element, index, array) {
        element.Graphics["x"] = parseFloat(element.Graphics["@CenterX"]) - parseFloat(element.Graphics["@Width"])/2;
        element.Graphics["y"] = parseFloat(element.Graphics["@CenterY"]) - parseFloat(element.Graphics["@Height"])/2;
        delete element.Graphics["@CenterX"];
        delete element.Graphics["@CenterY"];

        element.Graphics["@Width"] = parseFloat(element.Graphics["@Width"]);
        element.Graphics["@Height"] = parseFloat(element.Graphics["@Height"]);

      });
    }
    catch (e) {
      console.log("No Labels found.");
    }

    // Shapes

    try {
      parsedJson.Pathway.Shapes = convertToArray( parsedJson.Pathway.Shape );
      delete parsedJson.Pathway.Shape;

      parsedJson.Pathway.Shapes.forEach(function(element, index, array) {
        element.Graphics["x"] = parseFloat(element.Graphics["@CenterX"]) - parseFloat(element.Graphics["@Width"])/2;
        element.Graphics["y"] = parseFloat(element.Graphics["@CenterY"]) - parseFloat(element.Graphics["@Height"])/2;
        delete element.Graphics["@CenterX"];
        delete element.Graphics["@CenterY"];

        element.Graphics["@Width"] = parseFloat(element.Graphics["@Width"]);
        element.Graphics["@Height"] = parseFloat(element.Graphics["@Height"]);

        if (element.Graphics.hasOwnProperty("@FillColor")) {

          // does not deal with color if user entered "white". Should use validateColor() to address.

          element.Graphics["@FillColor"] = "#" + element.Graphics["@FillColor"]
        }
        else {
          element.Graphics['@FillColor'] = "#ffffff";
        };	

        if (element.Graphics.hasOwnProperty("@Color")) {
          element.Graphics["@Color"] = "#" + element.Graphics["@Color"]
        }
        else {
          element.Graphics['@Color'] = "#000000";
        };	

        if (!(element.Graphics.hasOwnProperty("@FontName"))) {
          element.Graphics['@FontName'] = "arial";
        };	

        if ((!(element.Graphics.hasOwnProperty("@ShapeType"))) || (element.Graphics["@ShapeType"] === 'Rectangle')) {
          element.Graphics["@ShapeType"] = "rectangle";
        }
        else {
          if (shapeMappings.hasOwnProperty(element.Graphics["@ShapeType"])) {
            element.Graphics['@ShapeType'] = shapeMappings[element.Graphics['@ShapeType']];
          }
        };	

      });
    }
    catch (e) {
      console.log("No Shapes found.");
    }

    console.log('parsedJson.Pathway');
    console.log(parsedJson.Pathway);
    return parsedJson.Pathway;
  }
  else {
    alert("Pathvisio.js does not support the data format provided. Please convert to GPML and retry.")
    console.log("Pathvisio.js does not support the data format provided. Please convert to GPML and retry.")
    return;
  }
};

function clone(selector) {
  var node = d3.select(selector).node();
  return d3.select(node.parentNode.insertBefore(node.cloneNode(true), node.nextSibling));
};

$(document).ready(function() {
d3.xml("../../samples/gpml/WP673_63184.gpml", "application/xml", function(xml) {
 //d3.xml("../../samples/gpml/ovalandpentagon.gpml", "application/xml", function(xml) {
  var pathway = convertGpml2Json(xml);
  console.log(pathwayc = pathway);

  var drag = d3.behavior.drag()
  .on("drag", dragmove);

  var svg = d3.select("#pathway-container").select(function() {
    return this.contentDocument.documentElement;
  });

   svg.attr('width', pathway.Graphics["@BoardWidth"]);
   svg.attr('height', pathway.Graphics["@BoardHeight"]);
  console.log('svg');
  console.log(svg);
  var doc = d3.select('#pathway-container')[0][0].contentDocument;
  var viewport = doc.getElementById('viewport');
  console.log('viewport');
  console.log(viewport);
  viewport.remove();

  console.log('svg in d3.xml()xml,svg');
  console.log(svg);

  var symbolsAvailable = svg.selectAll('symbol');
  var markersAvailable = svg.selectAll('marker');

  var pathwayNameText = svg.append('text')
  .attr("id", 'pathway-name-text')
  .attr("x", 80)
  .attr("y", 10)
  .text(function (d) { return 'Title: ' + pathway["@Name"] });

  var pathwayOrganismText = svg.append('text')
  .attr("id", 'pathway-organism-text')
  .attr("x", 80)
  .attr("y", 30)
  .text(function (d) { return 'Organism: ' + pathway["@Organism"] });

  // Data Nodes

  var dataNodesG = svg.selectAll("g.data-node")	
  .data(pathway.DataNodes)
  .enter()
  .append("g")
  .attr("id", function (d) {return 'datanode-g-' + d["@GraphId"]})
  .attr('transform', function(d) {return 'translate(' + d.Graphics.x + ' ' + d.Graphics.y + ')'})
  .attr("class", function (d) {return "data-node " + d["@Type"]})
  .call(drag);

  var dataNodesUses = dataNodesG.each(function(d) {
    var dataNodeUse = d3.select(this).append('use')
    .attr("id", function (d) {return 'datanode-use-' + d["@GraphId"]})
    .attr("class", function (d) {return "data-node " + d["@Type"]})
    .attr("x", 0)
    .attr("y", 0)
    .attr("width", function (d) {return d.Graphics["@Width"]})
    .attr("height", function (d) {return d.Graphics["@Height"]});
    
    if (!(!(d.Graphics['@Color']))) {
      dataNodeUse.attr("style", function (d) {return "stroke:" + d.Graphics["@Color"] + ";"})
    }

    if (!(!(d.Graphics['@FillColor']))) {
      dataNodeUse.attr("style", function (d) {return "fill:" + d.Graphics["@FillColor"] + ";"})
    }

    if (symbolsAvailable.filter(function(d, i) { return (symbolsAvailable[0][i].id === pathway.DataNodes[0].Graphics['@ShapeType']); }).length > 0) {
      // d3 bug strips 'xlink' so need to say 'xlink:xlink'
      dataNodeUse.attr("xlink:xlink:href", function (d) {return "#" + d.Graphics["@ShapeType"]})
    }
    else {
      dataNodeUse.attr("xlink:xlink:href", "#rectangle")
      console.log('Pathvisio.js does not have access to the requested shape: ' + pathway.DataNodes[0].Graphics['@ShapeType'] )
    };

    var dataNodeText = d3.select(this).append('text')
    .attr("id", function (d) {return 'datanode-text-' + d["@GraphId"]})
    .attr("x", function (d) {return d.Graphics["@Width"] / 2 })
    // TODO replace '12' with the actual font-size
    .attr("y", function (d) {return d.Graphics["@Height"] / 2 + 0.3*12 })
    .text(function (d) {return d["@TextLabel"]});

    if (!(!(d.Graphics['@Color']))) {
      dataNodeText.attr("style", function (d) {return "fill:" + d.Graphics["@Color"] + ";"})
    }

  });

  // Symbols/Shapes

  var shapesG = svg.selectAll("g.shape")	
  .data(pathway.Shapes)
  .enter()
  .append("g")
  .attr("id", function (d) {return 'g-shapes' + d["@GraphId"]})
  .attr("class", "shape")
  .attr('transform', function(d) {return 'translate(' + d.Graphics.x + ' ' + d.Graphics.y + ')'})
  .call(drag);

  var shapeUses = shapesG.each(function(d) {
    var shapeUse = d3.select(this).append('use')
    .attr("id", function (d) {return 'use-shape-' + d["@GraphId"]})
    .attr("class", function (d) {return "data-node " + d["@Type"]})
    .attr("x", 0)
    .attr("y", 0)
    .attr("width", function (d) {return d.Graphics["@Width"]})
    .attr("height", function (d) {return d.Graphics["@Height"]});

    if (!(!(d.Graphics['@Color']))) {
      shapeUse.attr("style", function (d) {return "stroke:" + d.Graphics["@Color"] + ";"})
    }

    if (!(!(d.Graphics['@FillColor']))) {
      shapeUse.attr("style", function (d) {return "fill:" + d.Graphics["@FillColor"] + ";"})
    }

    if (symbolsAvailable.filter(function(d, i) { return (symbolsAvailable[0][i].id === pathway.Shapes[0].Graphics['@ShapeType']); }).length > 0) {
      // d3 bug strips 'xlink' so need to say 'xlink:xlink'
      shapeUse.attr("xlink:xlink:href", function (d) {return "#" + d.Graphics["@ShapeType"]})
    }
    else {
      shapeUse.attr("xlink:xlink:href", "#rectangle")
      console.log('Pathvisio.js does not have access to the requested shape: ' + pathway.Shapes[0].Graphics['@ShapeType'] )
    };

    var shapeText = d3.select(this).append('text')
    .attr("id", function (d) {return 'shape-text-' + d["@GraphId"]})
    .attr("x", function (d) {return d.Graphics["@Width"] / 2 })
    // TODO replace '12' with the actual font-size
    .attr("y", function (d) {return d.Graphics["@Height"] / 2 + 0.3*12 })
    .text(function (d) {return d["@TextLabel"]});

    if (!(!(d.Graphics['@Color']))) {
      shapeText.attr("style", function (d) {return "fill:" + d.Graphics["@Color"] + ";"})
    }

  });

  // Labels 

  var labelsG = svg.selectAll("g.label")	
  .data(pathway.Labels)
  .enter()
  .append("g")
  .attr("id", function (d) {return 'labels-g-' + d["@GraphId"]})
  .attr("class", "label")
  .attr('transform', function(d) {return 'translate(' + d.Graphics.x + ' ' + d.Graphics.y + ')'})
  .call(drag);

  var labelsUses = labelsG.each(function(d) {
    var labelUse = d3.select(this).append('use')
    .attr("id", function (d) {return 'label-use-' + d["@GraphId"]})
    .attr("class", function (d) {return "data-node " + d["@Type"]})
    .attr("x", 0)
    .attr("y", 0)
    .attr("width", function (d) {return d.Graphics["@Width"]})
    .attr("height", function (d) {return d.Graphics["@Height"]});

    if (!(!(d.Graphics['@Color']))) {
      labelUse.attr("style", function (d) {return "stroke:" + d.Graphics["@Color"] + ";"})
    }

    if (!(!(d.Graphics['@FillColor']))) {
      labelUse.attr("style", function (d) {return "fill:" + d.Graphics["@FillColor"] + ";"})
    }

    if (symbolsAvailable.filter(function(d, i) { return (symbolsAvailable[0][i].id === pathway.Labels[0].Graphics['@LabelType']); }).length > 0) {
      // d3 bug strips 'xlink' so need to say 'xlink:xlink'
      labelUse.attr("xlink:xlink:href", function (d) {return "#" + d.Graphics["@ShapeType"]})
    }
    else {
      labelUse.attr("xlink:xlink:href", "#rectangle")
      console.log('Pathvisio.js does not have access to the requested shape: ' + pathway.Labels[0].Graphics['@ShapeType'] )
    };

    var labelText = d3.select(this).append('text')
    .attr("id", function (d) {return 'label-text-' + d["@GraphId"]})
    .attr("x", function (d) {return d.Graphics["@Width"] / 2 })
    // TODO replace '12' with the actual font-size
    .attr("y", function (d) {return d.Graphics["@Height"] / 2 + 0.3*12 })
    .text(function (d) {return d["@TextLabel"]});

    if (!(!(d.Graphics['@Color']))) {
      labelText.attr("style", function (d) {return "fill:" + d.Graphics["@Color"] + ";"})
    }

  });

// Interactions

  function getMarkers(d) {
    var marker = {};
    marker.start = null;
    marker.end = null;
    d.Graphics.Points.forEach(function(element, index, array) {
      if ((element.position === 'start') && (element.hasOwnProperty('marker'))) {
        if (markersAvailable.filter(function(d, i) { return (markersAvailable[0][i].id === element.marker + '-start-black'); }).length > 0) {
          marker.start = element.marker + '-start-black'; 
        }
        else {
          console.log('Pathvisio.js does not have access to the requested marker: ' + element.marker )
          marker.start = element.marker + 'arrow-start-black'; 
        };
      }
      else {
        if ((element.position === 'end') && (element.hasOwnProperty('marker'))) {
          if (markersAvailable.filter(function(d, i) { return (markersAvailable[0][i].id === element.marker + '-end-black'); }).length > 0) {
            marker.end = element.marker + '-end-black'; 
          }
          else {
            console.log('Pathvisio.js does not have access to the requested marker: ' + element.marker )
            marker.end = element.marker + 'arrow-end-black'; 
          };
        }
      };
      return marker;
    });
    return marker;
  };

  function getPathData(d) {
    var pathData = "";
    d.Graphics.Points.forEach(function(element, index, array) {
      if (index === 0) {
        pathData = "M " + element["@X"] + " " + element["@Y"]; 
      }
      else {
        pathData += " L " + element["@X"] + " " + element["@Y"]; 
      };
      return pathData;
    });
    return pathData;
  };

  var interactions = svg.selectAll("path.interaction")
  .data(pathway.Interactions)
  .enter()
  .append("path")
  .attr("id", function (d) { return 'interaction-' + d["@GraphId"]; })
  .attr("class", "interaction")
  .attr("d", function (d) { return getPathData(d); })
  .attr("stroke", '#000000')
  .attr("fill", 'none')

  if (getMarkers(pathway.Interactions[0]).start !== null) {
    interactions.attr("marker-start", function (d) { return "url(#" + getMarkers(d).start + ")"; })
  }
  if (getMarkers(pathway.Interactions[0]).end !== null) {
    interactions.attr("marker-end", function (d) { return "url(#" + getMarkers(d).end + ")"; })
  }

  //.attr("x", d.x = d3.event.x)
  //.attr("y", d.y = d3.event.y);

  function dragmove(d) {
    console.log(
      "x: " + d3.event.x + ", " + 
      "y: " + d3.event.y + ", " + 
      "dx: " + d3.event.dx + ", " + 
      "dy: " + d3.event.dy);
      d.x=d3.event.x;
      d.y=d3.event.y;
      d3.select(this)
      .attr("x", d3.event.x)
      .attr("y", d3.event.y);
  }	

  /*var rectAttrs = rect
    .attr("x", function (pathway.DataNodes) {return pathway.DataNodes.Graphics["-CenterX"]/20 - pathway.DataNodes.Graphics["-Width"]/40})
    .attr("y", function (pathway.DataNodes) {return pathway.DataNodes.Graphics["-CenterY"]/20 - pathway.DataNodes.Graphics["-Height"]/40})
    .attr("width",function (pathway.DataNodes) {return pathway.DataNodes.Graphics["-Width"]/20} )
    .attr("height", function (pathway.DataNodes) {return pathway.DataNodes.Graphics["-Height"]/20})
    .style("fill", "#FFF")
    .style("stroke", function (pathway.DataNodes) {return pathway.DataNodes.Graphics["-Color"]});

    var text = svg.selectAll("text")
    .data(pathway.DataNodes)
    .enter()
    .append("text");

    var textAttrs = text
    .attr("x", function (pathway.DataNodes) {return pathway.DataNodes.Graphics["-CenterX"]/20 - pathway.DataNodes.Graphics["-Width"]/40})
    .attr("y", function (pathway.DataNodes) {return pathway.DataNodes.Graphics["-CenterY"]/20 - pathway.DataNodes.Graphics["-Height"]/40})
    .attr("dy", function (pathway.DataNodes) {return pathway.DataNodes.Graphics["-Height"]/25})
    .attr("dx", 5)
    .text(function (pathway.DataNodes) {return pathway.DataNodes["-TextLabel"]})
    .style("fill", function (pathway.DataNodes) {return pathway.DataNodes.Graphics["-Color"]});

    var line = svg.selectAll("line")
    .data(lines)
    .enter()
    .append("line");

    var lineAttrs = line
    .attr("x1", function(lines) { return lines.Graphics.Point[0]["-x"]/20})
    .attr("y1", function(lines) { return lines.Graphics.Point[0]["-y"]/20})
    .attr("x2", function(lines) { return lines.Graphics.Point[1]["-x"]/20})
    .attr("y2", function(lines) { return lines.Graphics.Point[1]["-y"]/20})
    .style("stroke", function(lines) { return lines.Graphics["-Color"]});*/
});

/*
// If users want to use pathvisio.js from another domain without copying over the full source,
// they will need to be able to access pathwayDefs.svg from a non-WikiPathways domain. For widget
// functionality, an iframe would suffice. For example, cross-origin policy would block 
// pathwayDefs.svg from being loaded for visitors accessing 
// http://127.0.0.1/~andersriutta/d3-from-gpml-using-defs/pathway-from-defs.html,
// but with an iframe, as in example at ./iframeWidget.html, pathwayDefs.svg would be on the same
// origin as the script request.
// To provide this, replace the appropriate line below with this line:
d3.xml("http://192.168.42.84/~andersriutta/d3-from-gpml-using-defs/pathwayDefs.svg", "image/svg+xml", function(xml) {

// If we wanted to request pathwayDefs.svg with a GET request, we could use JSONP, but
// this would require changing server side settings. For more informatiion, see:
// http://stackoverflow.com/questions/1678214/javascript-how-do-i-create-jsonp

$.ajax({
type: "GET",
url: "http://192.168.42.84/~andersriutta/d3-from-gpml-using-defs/pathwayDefs.svg",
dataType: "jsonp text",
success: function(xmlResponse) {
// process data 
console.log(xmlResponse);
}
});

// It would also be possible to recreate pathwayDefs.svg using d3.js. I'm not sure is faster:
// downloading an already created pathwayDefs.svg or drawing it with d3. This is something to
// test later on.

// One of the big benefits of using pathwayDefs.svg is that editing the SVG is probably more
// accessible for maintainability than editing the d3 code (if pathwayDefs.svg were created
// using d3). It would be possible to do both: download pathwayDefs.svg if on WikiPathways.org
// domain or recreate it with d3 if not. Is it possible to create d3 code from an existing
// svg?
 */

});
</script>
