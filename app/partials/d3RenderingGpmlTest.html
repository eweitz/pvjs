<!DOCTYPE html>
<meta charset="utf-8">
<title>pathvisio.js renderer</title>

<!-- 
Style guides can be arbitrary, but for sake of consistency within this project, let's use these:
http://google-styleguide.googlecode.com/svn/trunk/htmlcssguide.xml
http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml
-->

<script src="http://mbostock.github.com/d3/d3.js?1.27.1"></script>
<script src="../js/xml2json.js"></script>
<script src="../js/jquery-1.9.1.js"></script>
<style>
text {
  font-size: 200px;
  font-family: "arial";
}
</style>
<script src="http://code.jquery.com/jquery-latest.min.js"></script>

<object id="pathway-container" data="pathwaydefs.svg" type="image/svg+xml" width="100%" height="1000"></object>

<script>
function convertToArray(object) {
  if (Object.prototype.toString.call( object ) === '[object Object]' ) {
    var array = [];
    array.push(object)
    return array;
  }
  else {
    if( Object.prototype.toString.call( object ) === '[object Array]' ) {
      return object;
    }
  }
}
function convertGpml2Json(xmlDoc){

  console.log('xmlDoc');
  console.log(xmlDoc);

  // We can use xml2json.js or JXON.js. Which is better?
  // JXON.js
  /*
     var parsedJson = {};
     parsedJson.Pathway = JXON.build(xmlDoc.documentElement);
   */

  // xml2json.js

  var json = xml2json(xmlDoc, "");
  var parsedJson = JSON.parse(json);
  var xmlns = "";

  try {
    xmlns = parsedJson.Pathway["@xmlns"]
  }
  catch (e) {
    console.log(e.message);
    return;
  }

  // test for whether file is GPML based on xmlns without reference to version

  var gpmlXmlnsSupported = "http://pathvisio.org/GPML/2013a";
  var gpmlXmlnsIdentifier = "/GPML/";

  // current and previous GPML xmlns values
  // "http://pathvisio.org/GPML/2013a"
  // "http://genmapp.org/GPML/2010a"
  // "http://genmapp.org/GPML/2008a"
  // "http://genmapp.org/GPML/2007"

  if ( xmlns.indexOf(gpmlXmlnsIdentifier) !== -1 ) {

    // test for whether the GPML file version matches the current version supported by pathvisio.js

    if (xmlns != gpmlXmlnsSupported) {

      // preferably, this would call the Java RPC updater for the file to be updated.

      alert("Pathvisio.js may not fully support the version of GPML provided (xmlns: " + xmlns + "). Please convert to the supported version of GPML (xmlns: " + gpmlXmlnsSupported + ").")
    }

    // Convert output from xml2json into well-formed JSON.
    // It would be better to do this in the conversion file xml2json.js.

    // BiopaxRefs

    try {
      parsedJson.Pathway.BiopaxRefs = convertToArray( parsedJson.Pathway.BiopaxRef );
      delete parsedJson.Pathway.BiopaxRef;

      parsedJson.Pathway.BiopaxRefs.forEach(function(element, index, array) {
        // modify data
      });
    }
    catch (e) {
      console.log("No BiopaxRefs found.");
    }

    // Comments 

    try {
      parsedJson.Pathway.Comments = convertToArray( parsedJson.Pathway.Comment );
      delete parsedJson.Pathway.Comment;

      parsedJson.Pathway.Comments.forEach(function(element, index, array) {

        // modify data

      });
    }
    catch (e) {
      console.log("No Comments found.");
    }

    // DataNodes 

    try {
      parsedJson.Pathway.DataNodes = convertToArray( parsedJson.Pathway.DataNode );
      delete parsedJson.Pathway.DataNode;

      parsedJson.Pathway.DataNodes.forEach(function(element, index, array) {
        element.Graphics["x"] = parseFloat(element.Graphics["@CenterX"]) - parseFloat(element.Graphics["@Width"])/2;
        element.Graphics["y"] = parseFloat(element.Graphics["@CenterY"]) - parseFloat(element.Graphics["@Height"])/2;
        delete element.Graphics["@CenterX"];
        delete element.Graphics["@CenterY"];

        element.Graphics["@Width"] = parseFloat(element.Graphics["@Width"]);
        element.Graphics["@Height"] = parseFloat(element.Graphics["@Height"]);

        if (element.Graphics.hasOwnProperty("@FillColor")) {

          // does not deal with color if user entered "white". Should use validateColor() to address.

          element.Graphics["@FillColor"] = "#" + element.Graphics["@FillColor"]
        }
        else {
          element.Graphics['@FillColor'] = "#ffffff";
        };	

        if (element.Graphics.hasOwnProperty("@Color")) {
          element.Graphics["@Color"] = "#" + element.Graphics["@Color"]
        }
        else {
          element.Graphics['@Color'] = "#000000";
        };	

        if (!(element.Graphics.hasOwnProperty("@FontName"))) {
          element.Graphics['@FontName'] = "arial";
        };	

        // GPML to jGPML shape name mappings: { 'oldName':'new-name' }

        var shapeMappings = { 'Brace':'shape-brace',  'Rectangle':'shape-rect', 'RoundedRectangle':'shape-rounded-rect', 'Oval':'shape-ellipse', 'Endoplasmic Reticulum':'shape-endoplasmic-reticulum', 'Golgi Apparatus':'shape-golgi-apparatus', 'Mitochondria':'shape-mitochondrion', 'Triangle':'shape-triangle', 'Pentagon':'shape-pentagon', 'Hexagon':'shape-hexagon', 'Sarcoplasmic Reticulum':'shape-sarcoplasmic-reticulum' };

        if ((!(element.Graphics.hasOwnProperty("@ShapeType"))) || (element.Graphics["@ShapeType"] === 'Rectangle')) {
          console.log(element.Graphics["@ShapeType"]);
          element.Graphics["@ShapeType"] = "shape-rect";
        }
        else {
          if (shapeMappings.hasOwnProperty(element.Graphics["@ShapeType"])) {
            element.Graphics['@ShapeType'] = shapeMappings[element.Graphics['@ShapeType']];
          }
        };	

        // GPML to jGPML type name mappings: { 'oldName':'new-name' }

        var typeMappings = { 'GeneProduct':'gene-product',  'Metabolite':'metabolite', 'Pathway':'pathway', 'Protein':'protein', 'Unknown':'unknown' };
        if (typeMappings.hasOwnProperty(element["@Type"])) {
          element["@Type"] = typeMappings[element["@Type"]];
        }

      });
    }
    catch (e) {
      console.log("No DataNodes found.");
    }

    // Groups

    try {
      parsedJson.Pathway.Groups = convertToArray( parsedJson.Pathway.Group );
      delete parsedJson.Pathway.Group;

      parsedJson.Pathway.Groups.forEach(function(element, index, array) {

        // modify data

      });
    }
    catch (e) {
      console.log("No Groups found.");
    }

    // Interactions

    try {
      parsedJson.Pathway.Interactions = convertToArray( parsedJson.Pathway.Interaction );
      delete parsedJson.Pathway.Interaction;

      parsedJson.Pathway.Interactions.forEach(function(element, index, array) {
        element.Graphics.Points = convertToArray( element.Graphics.Point );
        delete element.Graphics.Point;

        // modify data

      });
    }
    catch (e) {
      console.log("No Interactions found.");
    }

    // Labels

    try {
      parsedJson.Pathway.Labels = convertToArray( parsedJson.Pathway.Label );
      delete parsedJson.Pathway.Label;

      parsedJson.Pathway.Labels.forEach(function(element, index, array) {

        // modify data

      });
    }
    catch (e) {
      console.log("No Labels found.");
    }

    // Shapes

    try {
      parsedJson.Pathway.Shapes = convertToArray( parsedJson.Pathway.Shape );
      delete parsedJson.Pathway.Shape;

      parsedJson.Pathway.Shapes.forEach(function(element, index, array) {
        element.Graphics["x"] = parseFloat(element.Graphics["@CenterX"]) - parseFloat(element.Graphics["@Width"])/2;
        element.Graphics["y"] = parseFloat(element.Graphics["@CenterY"]) - parseFloat(element.Graphics["@Height"])/2;
        delete element.Graphics["@CenterX"];
        delete element.Graphics["@CenterY"];

        element.Graphics["@Width"] = parseFloat(element.Graphics["@Width"]);
        element.Graphics["@Height"] = parseFloat(element.Graphics["@Height"]);

        if (element.Graphics.hasOwnProperty("@FillColor")) {

          // does not deal with color if user entered "white". Should use validateColor() to address.

          element.Graphics["@FillColor"] = "#" + element.Graphics["@FillColor"]
        }
        else {
          element.Graphics['@FillColor'] = "#ffffff";
        };	

        if (element.Graphics.hasOwnProperty("@Color")) {
          element.Graphics["@Color"] = "#" + element.Graphics["@Color"]
        }
        else {
          element.Graphics['@Color'] = "#000000";
        };	

        if (!(element.Graphics.hasOwnProperty("@FontName"))) {
          element.Graphics['@FontName'] = "arial";
        };	

        // GPML to jGPML shape name mappings: { 'oldName':'new-name' }

        var shapeMappings = { 'Brace':'shape-brace',  'Rectangle':'shape-rect', 'RoundedRectangle':'shape-rounded-rect', 'Oval':'shape-ellipse', 'Endoplasmic Reticulum':'shape-endoplasmic-reticulum', 'Golgi Apparatus':'shape-golgi-apparatus', 'Mitochondria':'shape-mitochondrion', 'Triangle':'shape-triangle', 'Pentagon':'shape-pentagon', 'Hexagon':'shape-hexagon', 'Sarcoplasmic Reticulum':'shape-sarcoplasmic-reticulum' };

        if ((!(element.Graphics.hasOwnProperty("@ShapeType"))) || (element.Graphics["@ShapeType"] === 'Rectangle')) {
          console.log(element.Graphics["@ShapeType"]);
          element.Graphics["@ShapeType"] = "shape-rect";
        }
        else {
          if (shapeMappings.hasOwnProperty(element.Graphics["@ShapeType"])) {
            element.Graphics['@ShapeType'] = shapeMappings[element.Graphics['@ShapeType']];
          }
        };	

      });
    }
    catch (e) {
      console.log("No Shapes found.");
    }

    console.log('parsedJson.Pathway');
    console.log(parsedJson.Pathway);
    return parsedJson.Pathway;
  }
  else {
    alert("Pathvisio.js does not support the data format provided. Please convert to GPML and retry.")
    console.log("Pathvisio.js does not support the data format provided. Please convert to GPML and retry.")
    return;
  }
};

function clone(selector) {
  var node = d3.select(selector).node();
  return d3.select(node.parentNode.insertBefore(node.cloneNode(true), node.nextSibling));
};

$(document).ready(function() {
d3.xml("../../samples/gpml/WP673_63184.gpml", "application/xml", function(xml) {
 //d3.xml("../../samples/gpml/ovalandpentagon.gpml", "application/xml", function(xml) {
  var pathway = convertGpml2Json(xml);
  console.log(pathwayc = pathway);

  var drag = d3.behavior.drag()
  .on("drag", dragmove);

  var svg = d3.select("#pathway-container").select(function() {
    console.log('this');
    console.log(this);
    return this.contentDocument.documentElement;
  });

   svg.attr('width', pathway.Graphics["@BoardWidth"]);
   svg.attr('height', pathway.Graphics["@BoardHeight"]);
  console.log('svg');
  console.log(svg);
  var doc = d3.select('#pathway-container')[0][0].contentDocument;
  var viewport = doc.getElementById('viewport');
  console.log('viewport');
  console.log(viewport);
  viewport.remove();

  console.log('svg in d3.xml()xml,svg');
  console.log(svg);

  var gDataNodes = svg.selectAll("g.data-node")	
  .data(pathway.DataNodes)
  .enter()
  .append("g")
  .attr("id", function (d) {return 'datanode-g-' + d["@GraphId"]})
  .attr('transform', function(d) {return 'translate(' + d.Graphics.x + ' ' + d.Graphics.y + ')'})
  .attr("class", function (d) {return "data-node " + d["@Type"]})
  .call(drag);

  var symbols = svg.selectAll('symbol');

  var usesDataNodes = gDataNodes.each(function(d) {
    var useDataNode = d3.select(this).append('use')
    .attr("id", function (d) {return 'datanode-use-' + d["@GraphId"]})
    .attr("class", function (d) {return "data-node " + d["@Type"]})
    .attr("x", 0)
    .attr("y", 0)
    .attr("width", function (d) {return d.Graphics["@Width"]})
    .attr("height", function (d) {return d.Graphics["@Height"]});

    if (symbols.filter(function(d, i) { return (symbols[0][i].id === pathway.DataNodes[0].Graphics['@ShapeType']); }).length > 0) {
      // d3 bug strips 'xlink' so need to say 'xlink:xlink'
      useDataNode.attr("xlink:xlink:href", function (d) {return "#" + d.Graphics["@ShapeType"]})
    }
    else {
      useDataNode.attr("xlink:xlink:href", "#shape-rect")
      console.log('Pathvisio.js does not have access to the requested shape: ' + pathway.DataNodes[0].Graphics['@ShapeType'] )
    };

    d3.select(this).append('text')
  .attr("id", function (d) {return 'datanode-text-' + d["@GraphId"]})
    .attr("x", function (d) {return d.Graphics["@Width"] / 2 })
    // TODO replace '12' with the actual font-size
    .attr("y", function (d) {return d.Graphics["@Height"] / 2 + 0.3*12 })
    .text(function (d) {return d["@TextLabel"]});
  });

  // symbols

  var gShapes = svg.selectAll("g.shape")	
  .data(pathway.Shapes)
  .enter()
  .append("g")
  .attr("id", function (d) {return 'shapes-g-' + d["@GraphId"]})
  .attr("class", "shape")
  .attr('transform', function(d) {return 'translate(' + d.Graphics.x + ' ' + d.Graphics.y + ')'})
  .call(drag);

  var symbols = svg.selectAll('symbol');

  var usesShapes = gShapes.each(function(d) {
    var useShape = d3.select(this).append('use')
  .attr("id", function (d) {return 'shapes-use-' + d["@GraphId"]})
    .attr("class", function (d) {return "data-node " + d["@Type"]})
    .attr("x", 0)
    .attr("y", 0)
    .attr("width", function (d) {return d.Graphics["@Width"]})
    .attr("height", function (d) {return d.Graphics["@Height"]});

    if (symbols.filter(function(d, i) { return (symbols[0][i].id === pathway.Shapes[0].Graphics['@ShapeType']); }).length > 0) {
      // d3 bug strips 'xlink' so need to say 'xlink:xlink'
      useShape.attr("xlink:xlink:href", function (d) {return "#" + d.Graphics["@ShapeType"]})
    }
    else {
      useShape.attr("xlink:xlink:href", "#shape-rect")
      console.log('Pathvisio.js does not have access to the requested shape: ' + pathway.Shapes[0].Graphics['@ShapeType'] )
    };

    d3.select(this).append('text')
    .attr("id", function (d) {return 'shapes-text-' + d["@GraphId"]})
    .attr("x", function (d) {return d.Graphics["@Width"] / 2 })
    // TODO replace '12' with the actual font-size
    .attr("y", function (d) {return d.Graphics["@Height"] / 2 + 0.3*12 })
    .text(function (d) {return d["@TextLabel"]});
  });

  function getPathData(d) {
    var pathData = "";
    d.Graphics.Points.forEach(function(element, index, array) {
      if (index == 0) {
        pathData = "M " + element["@X"] + " " + element["@Y"]; 
      }
      else {
        pathData += " L " + element["@X"] + " " + element["@Y"]; 
      };
      return pathData;
    });
    console.log(pathData);
    return pathData;
  };

  var interactions = svg.selectAll("path.interaction")
  .data(pathway.Interactions)
  .enter()
  .append("path")
  .attr("id", function (d) {return 'interaction-' + d["@GraphId"]})
  .attr("class", "interaction")
  .attr("d", function (d) {return getPathData(d);})
  .attr("stroke", '#000000')
  .attr("fill", 'none')
  .attr("marker-end","url(#arrow-end-black)");
  
  //.attr("x", d.x = d3.event.x)
  //.attr("y", d.y = d3.event.y);

  function dragmove(d) {
    log.text(
      "x: " + d3.event.x + ", " + 
      "y: " + d3.event.y + ", " + 
      "dx: " + d3.event.dx + ", " + 
      "dy: " + d3.event.dy);
      d.x=d3.event.x;
      d.y=d3.event.y;
      d3.select(this)
      .attr("x", d3.event.x)
      .attr("y", d3.event.y);
  }	

  /*var rectAttrs = rect
    .attr("x", function (pathway.DataNodes) {return pathway.DataNodes.Graphics["-CenterX"]/20 - pathway.DataNodes.Graphics["-Width"]/40})
    .attr("y", function (pathway.DataNodes) {return pathway.DataNodes.Graphics["-CenterY"]/20 - pathway.DataNodes.Graphics["-Height"]/40})
    .attr("width",function (pathway.DataNodes) {return pathway.DataNodes.Graphics["-Width"]/20} )
    .attr("height", function (pathway.DataNodes) {return pathway.DataNodes.Graphics["-Height"]/20})
    .style("fill", "#FFF")
    .style("stroke", function (pathway.DataNodes) {return pathway.DataNodes.Graphics["-Color"]});

    var text = svg.selectAll("text")
    .data(pathway.DataNodes)
    .enter()
    .append("text");

    var textAttrs = text
    .attr("x", function (pathway.DataNodes) {return pathway.DataNodes.Graphics["-CenterX"]/20 - pathway.DataNodes.Graphics["-Width"]/40})
    .attr("y", function (pathway.DataNodes) {return pathway.DataNodes.Graphics["-CenterY"]/20 - pathway.DataNodes.Graphics["-Height"]/40})
    .attr("dy", function (pathway.DataNodes) {return pathway.DataNodes.Graphics["-Height"]/25})
    .attr("dx", 5)
    .text(function (pathway.DataNodes) {return pathway.DataNodes["-TextLabel"]})
    .style("fill", function (pathway.DataNodes) {return pathway.DataNodes.Graphics["-Color"]});


    var line = svg.selectAll("line")
    .data(lines)
    .enter()
    .append("line");

    var lineAttrs = line
    .attr("x1", function(lines) { return lines.Graphics.Point[0]["-x"]/20})
    .attr("y1", function(lines) { return lines.Graphics.Point[0]["-y"]/20})
    .attr("x2", function(lines) { return lines.Graphics.Point[1]["-x"]/20})
    .attr("y2", function(lines) { return lines.Graphics.Point[1]["-y"]/20})
    .style("stroke", function(lines) { return lines.Graphics["-Color"]});*/
});

/*
// If users want to use pathvisio.js from another domain without copying over the full source,
// they will need to be able to access pathwayDefs.svg from a non-WikiPathways domain. For widget
// functionality, an iframe would suffice. For example, cross-origin policy would block 
// pathwayDefs.svg from being loaded for visitors accessing 
// http://127.0.0.1/~andersriutta/d3-from-gpml-using-defs/pathway-from-defs.html,
// but with an iframe, as in example at ./iframeWidget.html, pathwayDefs.svg would be on the same
// origin as the script request.
// To provide this, replace the appropriate line below with this line:
d3.xml("http://192.168.42.84/~andersriutta/d3-from-gpml-using-defs/pathwayDefs.svg", "image/svg+xml", function(xml) {

// If we wanted to request pathwayDefs.svg with a GET request, we could use JSONP, but
// this would require changing server side settings. For more informatiion, see:
// http://stackoverflow.com/questions/1678214/javascript-how-do-i-create-jsonp

$.ajax({
type: "GET",
url: "http://192.168.42.84/~andersriutta/d3-from-gpml-using-defs/pathwayDefs.svg",
dataType: "jsonp text",
success: function(xmlResponse) {
// process data 
console.log(xmlResponse);
}
});

// It would also be possible to recreate pathwayDefs.svg using d3.js. I'm not sure is faster:
// downloading an already created pathwayDefs.svg or drawing it with d3. This is something to
// test later on.

// One of the big benefits of using pathwayDefs.svg is that editing the SVG is probably more
// accessible for maintainability than editing the d3 code (if pathwayDefs.svg were created
// using d3). It would be possible to do both: download pathwayDefs.svg if on WikiPathways.org
// domain or recreate it with d3 if not. Is it possible to create d3 code from an existing
// svg?
 */

});
</script>
